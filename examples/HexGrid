#!/usr/local/bin/perl

use strict;
use warnings;

use Readonly;
use Carp qw( croak );
use Try::Tiny;

use SDL;
use SDL::Rect;
use SDL::Surface;
use SDL::Video;
use SDL::Event;
use SDL::Events;
use Games::FrozenBubble::Stuff; # For the correct delay function

use lib "./lib";
use JGoff::Games::HexGrid::Draw;

Readonly my $TARGET_ANIM_SPEED => 60;
Readonly my %viewport => ( w => 640, h => 480, d => 24 );

my $frame = 0;
my $sdl_flags =
  SDL_HWSURFACE |
  SDL_DOUBLEBUF |
  SDL_HWACCEL |
  SDL_ASYNCBLIT;
my @update_rects;
my $app;
my $event = SDL::Event->new;

# {{{ Initialization

try {
  SDL::init(SDL_INIT_EVERYTHING);
  $app = SDL::Video::set_video_mode(
    $viewport{w}, $viewport{h}, $viewport{d}, 0, $sdl_flags
  );
}
catch {
  warn "Falling back to software surface";
  $app = SDL::Video::set_video_mode(
    $viewport{w}, $viewport{h}, $viewport{d}, SDL_SWSURFACE
  );
};
SDL::Events::enable_unicode(1);

# }}}

my %color = (
  black_opaque => SDL::Video::map_RGBA( $app->format(), 0, 0, 0, 255 ),
  red_opaque => SDL::Video::map_RGBA( $app->format(), 255, 0, 0, 255 ),
  green_opaque => SDL::Video::map_RGBA( $app->format(), 0, 255, 0, 255 ),
  blue_opaque => SDL::Video::map_RGBA( $app->format(), 0, 0, 255, 255 ),
);

# {{{ erase_image

sub erase_image {
  SDL::Video::fill_rect(
    $app,
    SDL::Rect->new(
      0, 0, $app->w, $app->h,
    ),
    $color{black_opaque}
  );
}

# }}}

# {{{ update_game

sub update_game {
  SDL::Events::pump_events();
  if ( SDL::Events::poll_event($event) ) {
    if ( $event->type == SDL_KEYDOWN ) {
      die "normal exit";
    }
  }
}

# }}}

# {{{ put_image

sub put_image {
  my $ghd = JGoff::Games::HexGrid::Draw->new(
    origin => [ 20, 20 ],
    cells => [ 10, 10 ],
    width => [ 40, 40 ]
  );
  $ghd->draw( surface => $app, color => $color{blue_opaque} );

  my $margin = 20;
  my $drect = SDL::Rect->new(
    $margin, $margin, $app->w - $margin, $app->h - $margin
  );
  push @update_rects, $drect;
}

# }}}

# {{{ maingame

sub maingame {
  my $synchro_ticks = SDL::get_ticks();

  erase_image;
  update_game;
  put_image;
  $frame++;

  SDL::Video::update_rects( $app, @update_rects );
  @update_rects = ();

  my $to_wait = $TARGET_ANIM_SPEED - (SDL::get_ticks() - $synchro_ticks);
  $to_wait > 0 and Games::FrozenBubble::CStuff::fbdelay($to_wait);
}

# }}}

# {{{ Main loop

while ( 1 ) {
  eval { maingame };
  last if $@ =~ /normal exit/;
  die $@ if $@;
}

# }}}
