#!/usr/local/bin/perl

use strict;
use warnings;

use Readonly;
use Carp qw( croak );
use Try::Tiny;

use SDL;
use SDL::Rect;
use SDL::Surface;
use SDL::Video;
use SDL::Event;
use SDL::Events;
use Games::FrozenBubble::Stuff; # For the correct delay function

use lib "./lib";
use JGoff::Games::HexGrid::Draw;

Readonly my $TARGET_ANIM_SPEED => 60;
Readonly my %viewport => ( w => 640, h => 480, d => 32 );
Readonly my %world => ( w => 1024, h => 768, d => 32 );

my @viewport_origin = ( 0, 0 );
my @viewport_velocity = ( 0, 0 );

my $frame = 0;
my $sdl_flags =
  SDL_HWSURFACE |
  SDL_DOUBLEBUF |
  SDL_HWACCEL |
  SDL_ASYNCBLIT;
my @update_rects;
my $event = SDL::Event->new;

my @actor = ( 0, 0 );

SDL::init(SDL_INIT_EVERYTHING);

my $app = SDL::Video::set_video_mode(
  $viewport{w}, $viewport{h}, $viewport{d}, 0
);
SDL::Events::enable_unicode(1);

my $ghd = JGoff::Games::HexGrid::Draw->new(
  origin => [ 5, 5 ],
  width => [ 40, 40 ],
  cells => [ 24, 24 ] # 24*40+5 = 1005 < 1024
                      # 24*40*0.75+5 = 725 < 768
);

#
# Create the hex-grid background
#
my $background = SDL::Surface->new(
  0, $world{w}, $world{h}, $world{d}, 0
);
SDL::Video::fill_rect(
  $background,
  SDL::Rect->new(
    0, 0, $background->w, $background->h,
  ),
  SDL::Video::map_RGBA( $background->format(), 0, 0, 0, 255 ),
);
$ghd->draw(
  surface => $background,
  color => SDL::Video::map_RGBA( $background->format(), 0, 0, 255, 255 ),
);

# {{{ erase_image

sub erase_image {
  SDL::Video::blit_surface(
    $background, SDL::Rect->new( @viewport_origin, $app->w, $app->h ),
    $app, SDL::Rect->new( 0, 0, $app->w, $app->h )
  );
}

# }}}

# {{{ update_game

sub update_game {
  SDL::Events::pump_events();
  if ( SDL::Events::poll_event($event) ) {
    if ( $event->type == SDL_KEYDOWN ) {
      if ( $event->key_sym == ord( 'i' ) ) {
        $actor[0]-- unless $actor[1] % 2;
        $actor[1]--
      }
      elsif ( $event->key_sym == ord( 'o' ) ) {
        $actor[0]++ if $actor[1] % 2;
        $actor[1]--
      }
      elsif ( $event->key_sym == ord( 'l' ) ) {
@viewport_velocity = ( 7/20, 0 ); # 1 column every 20 ticks
        $actor[0]++
      }
      elsif ( $event->key_sym == ord( ',' ) ) {
        $actor[0]++ if $actor[1] % 2;
        $actor[1]++
      }
      elsif ( $event->key_sym == ord( 'm' ) ) {
        $actor[0]-- unless $actor[1] % 2;
        $actor[1]++
      }
      elsif ( $event->key_sym == ord( 'j' ) ) {
@viewport_velocity = ( 0, 0 );
        $actor[0]--
      }
      else {
#die "[".$event->key_sym."]\n";
        die "normal exit";
      }
    }
  }

  if ( $viewport_velocity[0] > 0 ) {
    $viewport_origin[0] += $viewport_velocity[0];
  }
}

# }}}

# {{{ put_image

sub put_image {
  $ghd->draw_actor(
    coordinate => \@actor,
    surface => $app,
    color => SDL::Video::map_RGBA( $app->format(), 0, 0, 255, 255 )
  );

  my $margin = 5;
  my $drect = SDL::Rect->new(
    $margin, $margin, $app->w - $margin, $app->h - $margin
  );
  push @update_rects, $drect;
}

# }}}

# {{{ maingame

sub maingame {
  my $synchro_ticks = SDL::get_ticks();

  erase_image;
  update_game;
  put_image;
  $frame++;

  SDL::Video::update_rects( $app, @update_rects );
  @update_rects = ();

  my $delay = $TARGET_ANIM_SPEED -
              (SDL::get_ticks() - $synchro_ticks);
  $delay > 0 and Games::FrozenBubble::CStuff::fbdelay($delay);
}

# }}}

# {{{ Main loop

while ( 1 ) {
  eval { maingame };
  last if $@ =~ /normal exit/;
  die $@ if $@;
}

# }}}
