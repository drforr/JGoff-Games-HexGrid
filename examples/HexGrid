#!/usr/local/bin/perl

use strict;
use warnings;

use Readonly;
use Carp qw( croak );
use Try::Tiny;

use SDL;
use SDL::Rect;
use SDL::Surface;
use SDL::Video;
use SDL::Event;
use SDL::Events;
use Games::FrozenBubble::Stuff; # For the correct delay function

use lib "./lib";
use JGoff::Games::HexGrid::Draw;

Readonly my $TARGET_ANIM_SPEED => 60;
Readonly my %viewport => ( w => 640, h => 480, d => 24 );
Readonly my %world => ( w => 1024, h => 768, d => 24 );

my $frame = 0;
my $sdl_flags =
  SDL_HWSURFACE |
  SDL_DOUBLEBUF |
  SDL_HWACCEL |
  SDL_ASYNCBLIT;
my @update_rects;
my ( $app, $background );
my $event = SDL::Event->new;

# {{{ Initialization

try {
  SDL::init(SDL_INIT_EVERYTHING);
  $app = SDL::Video::set_video_mode(
    $viewport{w}, $viewport{h}, $viewport{d}, 0, $sdl_flags
  );
  $background = SDL::Surface->new(
    $sdl_flags, $world{w}, $world{h}, $world{d}
  );
}
catch {
  warn "Falling back to software surface";
  $app = SDL::Video::set_video_mode(
    $viewport{w}, $viewport{h}, $viewport{d}, SDL_SWSURFACE
  );
  $background = SDL::Surface->new(
    SDL_SWSURFACE, $world{w}, $world{h}, $world{d}, 0
  );
};
SDL::Events::enable_unicode(1);

# }}}

my %color = (
  black_opaque => SDL::Video::map_RGBA( $app->format(), 0, 0, 0, 255 ),
  red_opaque => SDL::Video::map_RGBA( $app->format(), 255, 0, 0, 255 ),
  green_opaque => SDL::Video::map_RGBA( $app->format(), 0, 255, 0, 255 ),
  blue_opaque => SDL::Video::map_RGBA( $app->format(), 0, 0, 255, 255 ),
);

my $ghd = JGoff::Games::HexGrid::Draw->new(
  origin => [ 20, 20 ],
  cells => [ 15, 10 ],
  width => [ 40, 40 ]
);
SDL::Video::fill_rect(
  $background,
  SDL::Rect->new(
    0, 0, $background->w, $background->h,
  ),
  $color{black_opaque}
);
$ghd->draw( surface => $background, color => $color{blue_opaque} );
$ghd->draw( surface => $app, color => $color{blue_opaque} );

# {{{ erase_image

sub erase_image {
#  SDL::Video::blit_surface(
#    $background, SDL::Rect->new( 0, 0, $app->w, $app->h ),
#    $app, SDL::Rect->new( 0, 0, $app->w, $app->h )
#  );
#$ghd->draw( surface => $app, color => $color{blue_opaque} );
  SDL::Video::update_rect( $app, 0, 0, $app->w, $app->h );
#  SDL::Video::fill_rect(
#    $app,
#    SDL::Rect->new(
#      0, 0, $app->w, $app->h,
#    ),
#    $color{black_opaque}
#  );
#$ghd->draw( surface => $app, color => $color{blue_opaque} );
}

# }}}

# {{{ update_game

sub update_game {
  SDL::Events::pump_events();
  if ( SDL::Events::poll_event($event) ) {
    if ( $event->type == SDL_KEYDOWN ) {
      die "normal exit";
    }
  }
}

# }}}

# {{{ put_image

sub put_image {
#  my $ghd = JGoff::Games::HexGrid::Draw->new(
#    origin => [ 20, 20 ],
#    cells => [ 15, 10 ],
#    width => [ 40, 40 ]
#  );
#  $ghd->draw( surface => $app, color => $color{blue_opaque} );

  my $margin = 20;
  my $drect = SDL::Rect->new(
#    $margin, $margin, $app->w - $margin, $app->h - $margin
0,0,640,480
  );
  push @update_rects, $drect;
}

# }}}

# {{{ maingame

sub maingame {
  my $synchro_ticks = SDL::get_ticks();

  erase_image;
  update_game;
  put_image;
  $frame++;

  SDL::Video::update_rects( $app, @update_rects );
  @update_rects = ();

  my $to_wait = $TARGET_ANIM_SPEED - (SDL::get_ticks() - $synchro_ticks);
  $to_wait > 0 and Games::FrozenBubble::CStuff::fbdelay($to_wait);
}

# }}}

# {{{ Main loop

while ( 1 ) {
  eval { maingame };
  last if $@ =~ /normal exit/;
  die $@ if $@;
}

# }}}
