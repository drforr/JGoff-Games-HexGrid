#!/usr/local/bin/perl

use strict;
use warnings;

use Readonly;
use Carp qw( croak );
use Try::Tiny;

use SDL;
use SDL::Rect;
use SDL::Surface;
use SDL::Video;
use SDL::Event;
use SDL::Events;
use Games::FrozenBubble::Stuff; # For the correct delay function

use lib "./lib";
use JGoff::Games::HexGrid::Draw;

Readonly my $TARGET_ANIM_SPEED => 60;
Readonly my %viewport => ( w => 640, h => 480, d => 32 );
Readonly my %world => ( w => 1024, h => 768, d => 32 );

my @viewport_origin = ( 0, 0 );
my @viewport_velocity = ( 0, 0 );

my $frame = 0;
my $sdl_flags =
  SDL_HWSURFACE |
  SDL_DOUBLEBUF |
  SDL_HWACCEL |
  SDL_ASYNCBLIT;
my @update_rects;
my $event = SDL::Event->new;

my @actor = ( 0, 0 );

SDL::init(SDL_INIT_EVERYTHING);

my $app = SDL::Video::set_video_mode(
  $viewport{w}, $viewport{h}, $viewport{d}, 0
);
SDL::Events::enable_unicode(1);

my $ghd = JGoff::Games::HexGrid::Draw->new(
  origin => [ 5, 5 ],
  cell_size => [ 40, 40 ],
  cells => [ 24, 24 ] # 24*40+5 = 1005 < 1024
                      # 24*40*0.75+5 = 725 < 768
);

# {{{ terrain

my @terrain = (
   #                       1 1 1 1 1 1 1 1 1 1 2 2 2 2 
   #   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
  [qw( . . . . . : : : : | | | : : : : : : . . . . . . )],
  [qw( . . . : : : : | | | | | | | | : : . . . . . . . )],
  [qw( . . : : : | | | | | | | | | : : . . : : : : . . )],
  [qw( . : : : | | | | | | | | : : . . . : : | | : : . )],
  [qw( . : : : : : : : : : : : : . . . . . . . . . . . )],
  [qw( : : : / / / / / : : . . . . . . . . . . . . . . )],
  [qw( . . : : v v v : : : . . . . . . . . . . . . . . )],
  [qw( . . : : / / / / : : . . . . . . . . . . . . . . )],
  [qw( . . . / / / / / / : . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )],
  [qw( . . . . . . . . . . . . . . . . . . . . . . . . )]
);

# }}}

#
# Create the hex-grid background
#
my $background = SDL::Surface->new(
  0, $world{w}, $world{h}, $world{d}, 0
);
SDL::Video::fill_rect(
  $background,
  SDL::Rect->new(
    0, 0, $background->w, $background->h,
  ),
  SDL::Video::map_RGBA( $background->format(), 0, 0, 0, 255 ),
);
$ghd->draw(
  surface => $background,
  color => SDL::Video::map_RGBA( $background->format(), 0, 0, 255, 255 ),
);

my $alpha = 255;
my %color_code = (
  '.' => [ 0, 0, 255, $alpha ],
  ':' => [ 0, 255, 0, $alpha ],
  '|' => [ 205, 133, 63, $alpha ],
  '/' => [ 192, 192, 192, $alpha ],
  'v' => [ 64, 64, 64, $alpha ],
);

my %tile;

for ( keys %color_code ) {
  $tile{$_} = $ghd->tile_surface(
    depth => $world{d},
    color => $color_code{$_}
  );
}
my $tile_rect = SDL::Rect->new( 0, 0, $tile{'.'}->w, $tile{'.'}->h );

for my $x ( 0 .. 23 ) {
  for my $y ( 0 .. 23 ) {
    my @bounding_box = $ghd->_bounding_box( coordinate => [ $x, $y ] );
    SDL::Video::blit_surface(
      $tile{$terrain[$x][$y]}, $tile_rect,
      $background,
      SDL::Rect->new( @bounding_box ),
    );
#last;
  }
#last;
}

#
# Create action layer
#
my $action = SDL::Surface->new(
  0, $world{w}, $world{h}, $world{d}, 0
);

# {{{ erase_image

sub erase_image {
  SDL::Video::blit_surface(
    $background, SDL::Rect->new( @viewport_origin, $app->w, $app->h ),
    $app, SDL::Rect->new( 0, 0, $app->w, $app->h )
  );
}

# }}}

# {{{ update_game

sub update_game {
  SDL::Events::pump_events();
  if ( SDL::Events::poll_event($event) ) {
    if ( $event->type == SDL_KEYDOWN ) {
      if ( $event->key_sym == ord( 'i' ) ) {
        $actor[0]-- unless $actor[1] % 2;
        $actor[1]--
      }
      elsif ( $event->key_sym == ord( 'o' ) ) {
        $actor[0]++ if $actor[1] % 2;
        $actor[1]--
      }
      elsif ( $event->key_sym == ord( 'l' ) ) {
@viewport_velocity = ( 7/20, 0 ); # 1 column every 20 ticks
        $actor[0]++
      }
      elsif ( $event->key_sym == ord( ',' ) ) {
        $actor[0]++ if $actor[1] % 2;
        $actor[1]++
      }
      elsif ( $event->key_sym == ord( 'm' ) ) {
        $actor[0]-- unless $actor[1] % 2;
        $actor[1]++
      }
      elsif ( $event->key_sym == ord( 'j' ) ) {
@viewport_velocity = ( 0, 0 );
        $actor[0]--
      }
      elsif ( $event->key_sym == ord( "\e" ) ) {
        die "normal exit";
      }
    }
  }

  if ( $viewport_velocity[0] > 0 ) {
    $viewport_origin[0] += $viewport_velocity[0];
  }
}

# }}}

# {{{ put_image

sub put_image {
  $ghd->draw_bounding_box(
    coordinate => \@actor,
    surface => $app,
    color => SDL::Video::map_RGBA( $app->format(), 255, 0, 0, 255 )
  );
#  $ghd->draw_hexagon(
#    coordinate => \@actor,
#    surface => $app,
#    color => SDL::Video::map_RGBA( $app->format(), 255, 0, 0, 255 )
#  );
#  $ghd->fill_hexagon(
#    coordinate => \@actor,
#    surface => $app,
#    color => SDL::Video::map_RGBA( $action->format(), 255, 0, 0, 127 )
#  );
  $ghd->draw_actor(
    coordinate => \@actor,
    surface => $app,
    color => SDL::Video::map_RGBA( $app->format(), 0, 0, 255, 127 )
  );

  push @update_rects, SDL::Rect->new( 0, 0, $app->w, $app->h );
}

# }}}

# {{{ maingame

sub maingame {
  my $synchro_ticks = SDL::get_ticks();

  erase_image;
  update_game;
  put_image;
  $frame++;

  SDL::Video::update_rects( $app, @update_rects );
  @update_rects = ();

  my $delay = $TARGET_ANIM_SPEED -
              (SDL::get_ticks() - $synchro_ticks);
  $delay > 0 and Games::FrozenBubble::CStuff::fbdelay($delay);
}

# }}}

# {{{ Main loop

while ( 1 ) {
  eval { maingame };
  last if $@ =~ /normal exit/;
  die $@ if $@;
}

# }}}
